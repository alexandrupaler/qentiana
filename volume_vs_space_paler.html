<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" type="text/css" href="main.css"> 

        <script src="http://d3js.org/d3.v3.js"></script>
        <script src="http://cdn.jsdelivr.net/g/filesaver.js"></script>

        <script src="utilities.js"></script>
        <script src="austinhelpers.js"></script>

        <script>
            function approx_mult_factor(factor, value)
            {
                // return Math.round(factor * value)
                return Math.ceil(factor * value);
            }
        </script>

        <script>
            /*
                Parameters
            */
            var nr_items = 100;
            // log spaced volume scaling factor
            var global_v = local_logspace(-2, 2, nr_items);
            // scaling factor space
            var global_s = local_linspace(0, 2, nr_items);

            // var total_failure_rate = 0.0001;//99.99% reliability
            var total_failure_rate = 0.01;//99% reliability
            // data for minimum values
            var start_volume = 23 * 11;
            var start_space = 7;
            var phys_error_rate = 0.001;

            function logical_error_probability(d, p_cycle)
            {
                /*
                    Use equation from fowlers paper on logical error rate
                */
                var p0 = d * local_factorial(d);
                var p1 = local_factorial(((d+1)/2) - 1);
                var p2 = local_factorial((d+1)/2);
                var tmp =  p0 / ( p1 * p2 );

                return tmp * Math.pow(p_cycle, (d + 1)/2);
            }
            
            function calc_distance(p_err_out, p_cycle, spacetime_volume)
            {
                // Find the lowest distance for which the error rate of the whole circuit
                // is given by less than p_err_out. Given an error rate per step of p_cycle.  
                // python range is < or <=?
                var min_dist = 3;
                var max_dist = 99;

                for (var d = min_dist; d <= max_dist; d++)
                {
                    var log_err_prob = logical_error_probability(d, p_cycle);
                    var val_to_compare = 1 - Math.pow(( 1 - log_err_prob), spacetime_volume);

                    if(p_err_out > val_to_compare)
                    {
                        return d;
                    }
                }

                // "Could not find a suitable distance"
                return -1;
            }

            function number_of_physical_qubits(distance, space)
            {
                //  only looking at data qubits
                return space * distance * distance;
            }

            function calculate_total(volume, space, total_failure_rate, p_cycle_err)
            {
                // var dist = calc_distance(total_failure_rate, p_cycle_err, volume);

                // if(dist == -1)
                // {
                //     // ERROR
                //     return "ERROR";
                // }

                // var ret_obj = {};
                // ret_obj["dist"] = dist;
                // ret_obj["number_of_physical_qubits"] = number_of_physical_qubits(dist, space);
                // return ret_obj;

                var res = austin_data_qubits(space, volume, 99, p_cycle_err);

                var ret_obj = {};
                ret_obj["dist"] = res.distance;
                ret_obj["number_of_physical_qubits"] = res.qubits;
                return ret_obj;
            }

            function gen_data(total_failure_rate, start_volume, start_space, p_err)
            {
                // 2D Array
                var data = new Array();

                var ret_1 = calculate_total(start_volume, start_space, total_failure_rate, p_err);

                for (var i=0; i<global_v.length; i++)
                {
                    for(var j=0; j < global_s.length; j++)
                    {
                        var space_param = approx_mult_factor(global_s[j], start_space);
                        var vol_param = approx_mult_factor(global_v[i], start_volume);
                        var ret_2 = calculate_total(vol_param, space_param, total_failure_rate, p_err);

                        if ((ret_1 == "ERROR") || (ret_2 == "ERROR"))
                        {
                            console.log("SOMETHING WENT WRONG!!!");
                        }

                        var ratio = (ret_2["number_of_physical_qubits"])/ (ret_1["number_of_physical_qubits"]);

                        data.push({
                            x: global_s[j],
                            y: global_v[i],
                            dist_opt_vol : ret_1.dist,
                            dist_opt_space : ret_2.dist,
                            nr_target_vol : ret_1["number_of_physical_qubits"],
                            nr_target_space : ret_2["number_of_physical_qubits"],
                            ratio: ratio
                        })
                    }
                }

                return data;
            }

            
        </script>
    </head>
    <body>
        <script src="svgsaving.js"></script>

        <div id="controls">
                <!-- #slider error rate -->
                <div class="slidecontainer">
                    Initial volume: <div id="r1_value"></div>
                    <input type="range" min="100" max="10000" value="0" step="1" class="slider" id="myRange1">
                </div>
                <div class="slidecontainer">
                    Initial no. log. qubits: <div id="r2_value"></div>
                    <input type="range" min="5" max="500" value="0" step="1" class="slider" id="myRange2">
                </div>
                <div class="slidecontainer">
                    per cycle error: <div id="r3_value"></div>
                    <input type="range" min="0" max="0.1" value="0.000" step="0.001" class="slider" id="myRange3">
                </div>
                <!-- button for Download the current chart as SVG file-->
                <a href="#" download="tradeoff.svg" onclick="save_as_svg('plot')"> Download chart as SVG</a>
        </div>

        <script>
            document.getElementById("myRange1").value = start_volume;
            document.getElementById("myRange2").value = start_space;
            document.getElementById("myRange3").value = phys_error_rate;
        </script>

        <div style="overflow: hidden;">
            <div class="plot" style="float: left">
                <!-- Here should be the plot -->
            </div>

            <div id="console" style="height:900px; width: 800px; background-color: antiquewhite;overflow: hidden;">
            </div>
        </div>

        <script>
            function handleMouseOver(data, param2)
            {
                var curr_volume = approx_mult_factor(data.y, start_volume);
                var curr_space = approx_mult_factor(data.x, start_space);

                var output = document.getElementById("console");
                // clean console
                output.innerHTML = "";

                if(data.ratio <= 1)
                    output.style.color = "green";
                else
                    output.style.color = "red";

                output.innerHTML += data.x + " " + data.y + "->" + data.ratio + "<br>";
                output.innerHTML += "distance vol: " + data.dist_opt_vol + " having a hardware footprint of " + curr_space + " log qubits <br>";
                output.innerHTML += "distance space: " + data.dist_opt_space + " for a volume of " + curr_volume + "<br>";

                output.innerHTML += "tradeoff time scaling threshold<br>" + (data.x * data.y) + "<br>";
                output.innerHTML += "minimum scaling should be below tradeoff threshold:<br>" + data.dist_opt_space + "<br>";

                output.innerHTML += "<br>";
                output.innerHTML += "qub vol: " + data.nr_target_vol + "<br>";
                output.innerHTML += "qub spc: " + data.nr_target_space + "<br>";


                var vol_min_depth = Math.floor(start_volume / curr_space);
                if(start_volume % curr_space != 0)
                {
                    vol_min_depth++;
                }

                var volume_in_case_no_depth_scale = start_space * vol_min_depth;

                var threshold = Math.floor(curr_volume / volume_in_case_no_depth_scale);
                if(curr_volume % volume_in_case_no_depth_scale)
                {
                    threshold++;
                }
                output.innerHTML += "paler tradeoff time scaling threshold<br>" + threshold + "<br>";
            }

            var data = gen_data(total_failure_rate, start_volume, start_space, phys_error_rate);
            // console.log(calc_distance(0.01,0.008,1000))
            /*
                D3
            */
            var itemSize = 5;
            var cellSize = itemSize+1; // make them slightly overlap so there are no lines
            var margin = {top: 20, right: 20, bottom: 80, left: 80};
            
            var width = 650 - margin.right - margin.left;
            var height = 650 - margin.top - margin.bottom;

            // use for better axis formating
            var superscript = "⁰¹²³⁴⁵⁶⁷⁸⁹",
                formatPower = function(d) { return (d + "").split("").map(function(c) { return superscript[c]; }).join(""); },
                formatTick = function(d) { return 10 + formatPower(Math.round(Math.log(d) / Math.LN10)); };


            var xScale = d3.scale.linear()
                .domain([global_s[0],global_s[global_s.length-1]])
                .range([0, global_s.length * itemSize]);

            var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom");

            var yScale = d3.scale.log()
                .domain([global_v[0],global_v[global_v.length-1]])
                .range([global_v.length * itemSize,0]);

            var yAxis = d3.svg.axis()
                .scale(yScale)
                .ticks(6, function(d) { return 10 + formatPower(Math.round(Math.log(d) / Math.LN10)); })
                .orient("left");

            var svg = d3.select('.plot')
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


            var cells = svg.selectAll('rect')
                .data(data)
                .enter().append('g').append('rect')
                .attr('class', 'cell')
                .attr('width', cellSize)
                .attr('height', cellSize)
                .attr('y', function(d) { return yScale(d.y); })
                .attr('x', function(d) { return xScale(d.x); })
                .attr('fill', function(d) {return "rgb(" + to_rgb(d.ratio) + "," + to_rgb(d.ratio) + "," + to_rgb(d.ratio) + ")";})
                .on('mouseover', handleMouseOver);


            svg.append("g")
                .attr("class", "y axis")
                .attr("transform", "translate(0, " + (cellSize/2) + ")")
                .call(yAxis)
                .selectAll('text')
                .attr('font-weight', 'normal');

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(" + (cellSize/2) + ", " + (global_v.length + 1) * itemSize + ")")
                .call(xAxis)
                .selectAll('text')
                .attr('font-weight', 'normal')
                .style("text-anchor", "start");


            // draw lines
            xarray = local_linspace(0.01, 2, nr_items)
            var line = d3.svg.line()
            .x(function(d,i) {
                return xScale(d);})
            .y(function(d,i) {
                return yScale(1/(Math.pow(d,4)));});

            svg.append("svg:path").attr("d", line(xarray));

            // now add titles to the axes
            var movey = (global_v.length + 1) * itemSize;
            var movex = (global_s.length + 1) * itemSize;

            svg.append("text")
                .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
                .attr("transform", "translate("+ (-margin.left/2) +","+(movex/2)+")rotate(-90)")  // text is drawn off the screen top left, move down and out and rotate
                .text("Volume Factor");

            svg.append("text")
                .attr("text-anchor", "middle")  // this makes it easy to centre the text as the transform is applied to the anchor
                .attr("transform", "translate("+ (movex/2) +","+(movey + (margin.bottom / 2))+")")  // centre below axis
                .text("Space Factor");
        </script>

        <script>
            function update_data()
            {
                var data = gen_data(total_failure_rate, start_volume, start_space, phys_error_rate);

                svg.selectAll("rect")
                    .data(data)
                    .transition().duration(1000)
                    .style("fill", function(d) {return "rgb(" + to_rgb(d.ratio) + "," + to_rgb(d.ratio) + "," + to_rgb(d.ratio) + ")";});
            }

            /*
                Update functions
            */
            function update_error(new_value)
            {
                phys_error_rate = new_value;
                update_data();
            }


            function update_space(new_value)
            {
                start_space = new_value;
                update_data();
            }


            function update_volume(new_value)
            {
                start_volume = new_value;
                update_data();
            }
        </script>

        <script>
            /*Event handlers for html elements*/
            var slider1 = document.getElementById("myRange1");
            var output1 = document.getElementById("r1_value");
            output1.innerHTML = slider1.value; // Display the default slider value

            var slider2 = document.getElementById("myRange2");
            var output2 = document.getElementById("r2_value");
            output2.innerHTML = slider2.value; // Display the default slider value

            var slider3 = document.getElementById("myRange3");
            var output3 = document.getElementById("r3_value");
            output3.innerHTML = slider3.value; // Display the default slider value

            // Update the current slider value (each time you drag the slider handle)
            slider1.oninput = function() {
                output1.innerHTML = this.value;
                update_volume(this.value);
            } 

            // Update the current slider value (each time you drag the slider handle)
            slider2.oninput = function() {
                output2.innerHTML = this.value;
                update_space(this.value);
            } 

            // Update the current slider value (each time you drag the slider handle)
            slider3.oninput = function() {
                output3.innerHTML = this.value;
                update_error(this.value);
            }
        </script>
    </body>
</html>
