<html>
    <head>
        <script type="text/javascript" src="http://cdn.pydata.org/bokeh/release/bokeh-1.0.0.min.js"></script>
        <script type="text/javascript" src="http://cdn.pydata.org/bokeh/release/bokeh-widgets-1.0.0.min.js"></script>
        <script type="text/javascript" src="http://cdn.pydata.org/bokeh/release/bokeh-tables-1.0.0.min.js"></script>
        <script type="text/javascript" src="http://cdn.pydata.org/bokeh/release/bokeh-api-1.0.0.min.js"></script>

        <script>
        /*
            Utility functions
        */
        function local_logspace(start, stop, num=50)
        {
            //assume base = 10
            var ret = new Array(num);

            for(var i=0; i<num; i++)
            {
                ret[i] = Math.pow(10, start + stop/i);
            }

            return ret;
        }
        
        function local_linspace(start, stop, num=50)
        {
            var ret = new Array(num);

            for(var i=0; i<num; i++)
            {
                ret[i] = start + stop/i;
            }

            return ret;
        }

        function create_2d_array(dim1, dim2)
        {
            var ret = new Array(dim1);
            for(var i=0; i<dim1; i++)
            {
                ret[i] = new Array(dim2);
            }
            return ret;
        }
        </script>

        <script>
            /*
                Parameters
            */
            // log spaced volume scaling factor
            var global_v = local_logspace(0, 6, 100);
            // scaling factor space
            var global_s = local_linspace(1, 3, 100);

            var total_failure_rate = 0.01;
            // data for minimum values
            var volume_min = 23 * 11;
            var space_min = 7;
            var phys_error_rate = 0.001;

            /*
                Visualisation parameters
            */
            // # storage for image
            var img = null;
            // # figure
            var p = null;
            // # storage for image in figure
            var source = null; 

            function logical_error_probability(d, p_step)
            {
                // use equation from fowlers paper on logical error rate
                tmp = d*math.factorial(d) / (math.factorial(int((d+1)/2) - 1)
                    * math.factorial(int((d+1)/2)))
                return tmp * p_step**int(d+1)/2
            }
            
            function calc_distance(p_err_out, p_step, spacetime_volume, min_dist = 3, max_dist = 50)
            {
                // Find the lowest distance for which the error rate of the whole circuit
                // is given by less than p_err_out. Given an error rate per step of p_step.  
                // python range is < or <=?
                var log_err_prob = logical_error_probability(d, p_step);
                var val_to_compare = 1 - Math.pow(( 1 - log_err_prob), spacetime_volume);

                for (var d = min_dist; d <= max_dist; d++)
                {
                    if(p_err_out > val_to_compare)
                    {
                        return d;
                    }
                }

                // "Could not find a suitable distance"
                return -1;
                // throw ("Could not find a suitable distance");
            }

            function logical_error_from_volume(volume, total_failure_rate)
            {
                return Math.pow(total_failure_rate, 1./volume);
            }    

            function number_of_physical_qubits(distance, space)
            {
                //  only looking at data qubits
                return space * distance * distance;
            }

            function calculate_total(volume, space, total_failure_rate, p_step_err = 0.02)
            {
                var P_1 = logical_error_from_volume(volume, total_failure_rate);
                var dist = calc_distance(total_failure_rate, p_step_err, volume);

                if(dist == -1)
                {
                    // ERROR
                    return "ERROR"
                }

                var ret_obj = {};
                ret_obj["dist"] = dist;
                ret_obj["number_of_physical_qubits"] = number_of_physical_qubits(dist, space);
                return ret_obj;
            }

            function RGB_map(value)
            {
                // maps values to color
                // data > 1 -> volume optimized is better than space optimized

                // paler: return a string to be used in CSS?
                if (value > 1)
                {
                    // RED, GREEN, BLUE
                    return "rgb(255, 255,255)";
                }
                else
                { 
                    // gray area space optimized is better
                    var add = parseInt(value * 200);
                    // RED, GREEN, BLUE 
                    return "rbb(" + add + ", " + add + ", " + add + ")";
                }
            }

            function gen_data(total_failure_rate, volume_min, space_min, p_err)
            {
                // 2D Array
                var data = create_2d_array(global_v.length, global_s.length);

                for (var i=0; i<global_v.length; i++)
                {
                    for(var j=0; j < global_s.length; j++)
                    {
                        space_param = parseInt(space_min * s[j] + 0.5);
                        var ret_1 = calculate_total(volume_min, space_param, total_failure_rate, p_err);

                        vol_param = parseInt(volume_min * v[i] + 0.5);
                        var ret_2 = calculate_total(vol_param, space_min, total_failure_rate, p_err);

                        if ((ret_1 == "ERROR") || (ret_2 == "ERROR"))
                        {
                            console.log("SOMETHING WENT WRONG!!!");
                        }
                        data[i, j] = ret_2["number_of_physical_qubits"]/ret_1["number_of_physical_qubits"];
                    }
                }
                return data
            }

            function update_error(attrname, old_value, new_value)
            {
                // global total_failure_rate,volume_min,space_min,phys_error_rate
                phys_error_rate = new_value
                update_data()
            }


            function update_space(attrname, old_value, new_value)
            {
                // global total_failure_rate,volume_min,space_min,phys_error_rate
                space_min = new_value
                update_data()
            }


            function update_volume(attrname, old_value, new_value)
            {
                // global total_failure_rate,volume_min,space_min,phys_error_rate
                volume_min = new_value
                update_data()
            }

            function update_data()
            {
                var data = gen_data(total_failure_rate,volume_min,space_min, phys_error_rate);

                // view = img.view(dtype=np.uint8).reshape((len(v), len(s), 4))
                // # i is vertical coordinate
                // # j is horizontal coordinate
                for (var i=0; i<global_v.length; i++)
                {
                    for (var j=0; j<global_s.length; j++)
                    {
                        // view[i, j, 0]
                        // view[i, j, 1]
                        // view[i, j, 2] = RGB_map(data[i,j]);
                        // ALPHA
                        // view[i, j, 3] = 180; 
                        view[i, j] = RGB_map(data[i,j]);//without alpha
                    }
                }

                // source.data = {'image': [img]}
            }

            function plot_data(v, s, data)
            {
                // global img, p, source
                img = np.empty((len(v),len(s)), dtype=np.uint32)
                view = img.view(dtype=np.uint8).reshape((len(v), len(s), 4))

                // # i is vertical coordinate
                // # j is horizontal coordinate
                for (var i=0; i< v.length; i++)
                {
                    for (var j=0; j< s.length; j++)
                    {
                        view[i, j, 0], view[i, j, 1], view[i, j, 2] = RGB_map(data[i,j]);
                        view[i, j, 3] = 180 
                        // # ALPHA
                    }
                }

                p = figure(plot_height=400, plot_width=400, x_range=(s[0],s[-1]), y_range=(v[0],v[-1]), y_axis_type="log")

                source = ColumnDataSource({'image': [img]})
                p.image_rgba(image='image', x=s[0], y=v[0], dw=s[-1]-s[0], dh=v[-1]-v[0],source = source)
                
                // Styling
                p.title.text = 'Total Qubit Overhead: volume-optimal vs space-optimal'
                p.xaxis.axis_label = 'space-optimal factor'
                p.yaxis.axis_label = 'volume-optimal factor'

                // No toolbar and logo
                p.toolbar.logo = None
                p.toolbar_location = None

                // Legend
                items = []
                items += [("space-optimal has fewer qubits",[p.circle(i,i,color="gray",size=20)])]
                items += [("volume-optimal has fewer qubits",[p.circle(i,i,color="white",size=20)])]
                p.add_layout(Legend(items=items))
                p.legend.location = "bottom_right"


                // Slider error rate
                error_rate = Slider(title = "per cycle error", value=0.001, start=0.001, end=0.02, step=0.001, format="0[.]000")#,callback=callback)
                error_rate.on_change('value',update_error)

                // Slider min_volume
                min_volume_slider = Slider(title = "min_volume", value=23*11, start=100, end=10000, step=100, format="0")#,callback=callback)
                min_volume_slider.on_change('value',update_volume)

                // Slider min_space
                min_space_slider = Slider(title = "min_space", value=7, start=5, end=500, step=5, format="0")#,callback=callback)
                min_space_slider.on_change('value',update_space)

                // Layout
                inputs = column(error_rate,min_volume_slider, min_space_slider)
                curdoc().add_root(row(inputs, p, width=800))
                curdoc().title = "Total Qubit Overhead: volume-optimal vs space-optimal"
                return 
            }

            var data = gen_data(total_failure_rate, volume_min, space_min, phys_error_rate);
            plot_data(global_v, global_s, data);

        </script>
    </head>
</html>
