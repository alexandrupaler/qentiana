<!DOCTYPE html>
<html>
    <head>

    <style>
      .axis path,
      .axis line {
        fill: none;
        stroke: black;
        shape-rendering: crispEdges;
      }

      .axis text {
          font-family: sans-serif;
          font-size: 11px;
      }
    </style>
        <script src="http://d3js.org/d3.v3.js"></script>

        <script>
        /*
            Utility functions
        */
        function local_logspace(start, stop, num=50)
        {
            //assume base = 10
            var ret = new Array(num);

            var delta = (stop - start)/num;
            for(var i=0; i<num; i++)
            {
                ret[i] = Math.pow(10, start + delta * i);
            }

            return ret;
        }
        
        function local_linspace(start, stop, num=50)
        {
            var ret = new Array(num);

            var delta = (stop - start)/num;
            for(var i=0; i<num; i++)
            {
                ret[i] = start + delta * i;
            }

            return ret;
        }

        function create_2d_array(dim1, dim2)
        {
            var ret = new Array(dim1);
            for(var i=0; i<dim1; i++)
            {
                ret[i] = new Array(dim2);
            }
            return ret;
        }

        var local_factorial_cache = {};
        function local_factorial (n)
        {
            if (n == 0 || n == 1)
            {
                return 1;
            }
            if (local_factorial_cache[n+""] > 0)
            {
                return local_factorial_cache[n+""];
            }

            var part = 1;
            for(var fn = 2; fn <=n; fn++)
            {
                if (local_factorial_cache[fn+""] > 0)
                {
                    part = local_factorial_cache[fn+""];
                }
                else
                {
                    part = part * fn;
                    local_factorial_cache[fn+""] = part;
                }
            } 
            local_factorial_cache[n+""] = part;

            return local_factorial_cache[n+""];
        }

        local_factorial(100);

        </script>

        <script>
            /*
                Parameters
            */
            // log spaced volume scaling factor
            var global_v = local_logspace(0, 4, 100);
            // scaling factor space
            var global_s = local_linspace(1, 3, 100);

            var total_failure_rate = 0.01;
            // data for minimum values
            var volume_min = 23 * 11;
            var space_min = 7;
            //
            var phys_error_rate = 0.008;

            function logical_error_probability(d, p_step)
            {
                /*
                    Use equation from fowlers paper on logical error rate
                */
                var p0 = d * local_factorial(d);
                var p1 = local_factorial(((d+1)/2) - 1);
                var p2 = local_factorial((d+1)/2);
                var tmp =  p0 / ( p1 * p2 );

                return tmp * Math.pow(p_step, (d+1)/2);
            }
            
            function calc_distance(p_err_out, p_step, spacetime_volume)
            {
                // Find the lowest distance for which the error rate of the whole circuit
                // is given by less than p_err_out. Given an error rate per step of p_step.  
                // python range is < or <=?
                var min_dist = 3;
                var max_dist = 50;

                for (var d = min_dist; d <= max_dist; d++)
                {
                    var log_err_prob = logical_error_probability(d, p_step);
                    var val_to_compare = 1 - Math.pow(( 1 - log_err_prob), spacetime_volume);

                    if(p_err_out > val_to_compare)
                    {
                        return d;
                    }
                }

                // "Could not find a suitable distance"
                return -1;
            }

            function logical_error_from_volume(volume, total_failure_rate)
            {
                return Math.pow(total_failure_rate, 1./volume);
            }    

            function number_of_physical_qubits(distance, space)
            {
                //  only looking at data qubits
                return space * distance * distance;
            }

            function calculate_total(volume, space, total_failure_rate, p_step_err = 0.02)
            {
                var P_1 = logical_error_from_volume(volume, total_failure_rate);
                var dist = calc_distance(P_1, p_step_err, volume);

                if(dist == -1)
                {
                    // ERROR
                    return "ERROR";
                }

                var ret_obj = {};
                ret_obj["dist"] = dist;
                ret_obj["number_of_physical_qubits"] = number_of_physical_qubits(dist, space);
                return ret_obj;
            }

            function gen_data(total_failure_rate, volume_min, space_min, p_err)
            {
                // 2D Array
                //var data = create_2d_array(global_v.length, global_s.length);
                var data = new Array();

                for (var i=0; i<global_v.length; i++)
                {
                    for(var j=0; j < global_s.length; j++)
                    {
                        var space_param = Math.round(space_min * global_s[j] + 0.5);
                        var ret_1 = calculate_total(volume_min, space_param, total_failure_rate, p_err);

                        var vol_param = Math.round(volume_min * global_v[i] + 0.5);
                        var ret_2 = calculate_total(vol_param, space_min, total_failure_rate, p_err);

                        if ((ret_1 == "ERROR") || (ret_2 == "ERROR"))
                        {
                            console.log("SOMETHING WENT WRONG!!!");
                        }

                        //data[i][j] = ret_2["number_of_physical_qubits"]/ret_1["number_of_physical_qubits"];

                        var ratio = ret_2["number_of_physical_qubits"]/ret_1["number_of_physical_qubits"];

                        var int_color = ratio > 1 ? 255 : Math.round(ratio * 255);

                        data.push({
                            x: global_s[j],
                            y: global_v[i],
                            value: int_color
                        })
                    }
                }

                return data;
            }

        </script>
    </head>
    <body>
        <div id="controls">
                <!-- #slider error rate -->
                <div>
                    min_volume: <div id="r1_value"></div>
                    <input type="range" min="100" max="10000" value="253" step="1" class="slider" id="myRange1">
                </div>
                <div>
                    min_space: <div id="r2_value"></div>
                    <input type="range" min="5" max="500" value="7" step="1" class="slider" id="myRange2">
                </div>
                <div>
                    per cycle error: <div id="r3_value"></div>
                    <input type="range" min="0" max="1" value="0.008" step="0.001" class="slider" id="myRange3">
                </div>
        </div>

        <div class="plot">
            <!-- Here should be the plot -->
        </div>

        <script>
            var data = gen_data(total_failure_rate, volume_min, space_min, phys_error_rate);
            // console.log(data)

            /*
                D3
            */
            var itemSize = 5;
            var cellSize = itemSize - 1;
            var margin = {top: 120, right: 20, bottom: 20, left: 110};
            
            var width = 900 - margin.right - margin.left;
            var height = 900 - margin.top - margin.bottom;


            var xScale = d3.scale.linear()
                .domain([global_s[0],global_s[global_s.length-1]])
                .range([0, global_s.length * itemSize]);

            var xAxis = d3.svg.axis()
                .scale(xScale)
                .orient("bottom");

            var yScale = d3.scale.log()
                // .domain([global_v[0],global_v[global_v.length-1]])
                .domain([global_v[global_v.length-1], global_v[0]])
                .range([0, global_v.length * itemSize]);

            var yAxis = d3.svg.axis()
                .scale(yScale)
                .orient("left");


            var svg = d3.select('.plot')
                .append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


            var cells = svg.selectAll('rect')
                 .data(data)
                 .enter().append('g').append('rect')
                 .attr('class', 'cell')
                 .attr('width', cellSize)
                 .attr('height', cellSize)
                 .attr('y', function(d) { return yScale(d.y); })
                 .attr('x', function(d) { return xScale(d.x); })
                //  .attr('fill', function(d) {return "rgb(" + d.value + "," + d.value + "," + d.value + ")";});
                .attr('fill', function(d) {return "rgb(" + d.value + "," + d.value + "," + d.value + ")";});


            svg.append("g")
                .attr("class", "y axis")
                .call(yAxis)
                .selectAll('text')
                .attr('font-weight', 'normal');

            svg.append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0, " + (global_v.length + 1)* itemSize + ")")
                .call(xAxis)
                .selectAll('text')
                .attr('font-weight', 'normal')
                .style("text-anchor", "start");
            
        </script>

        <script>
        /*
            Update functions
        */
            function update_error(new_value)
            {
                phys_error_rate = new_value;
                update_data();
            }


            function update_space(new_value)
            {
                space_min = new_value;
                update_data();
            }


            function update_volume(new_value)
            {
                volume_min = new_value;
                update_data();
            }
        </script>

        <script>
            /*Event handlers for html elements*/
            var slider1 = document.getElementById("myRange1");
            var output1 = document.getElementById("r1_value");
            output1.innerHTML = slider1.value; // Display the default slider value

            var slider2 = document.getElementById("myRange2");
            var output2 = document.getElementById("r2_value");
            output2.innerHTML = slider2.value; // Display the default slider value

            var slider3 = document.getElementById("myRange3");
            var output3 = document.getElementById("r3_value");
            output3.innerHTML = slider3.value; // Display the default slider value

            // Update the current slider value (each time you drag the slider handle)
            slider1.oninput = function() {
                output1.innerHTML = this.value;
                update_volume(this.value);
            } 

            // Update the current slider value (each time you drag the slider handle)
            slider2.oninput = function() {
                output2.innerHTML = this.value;
                update_space(this.value);
            } 

            // Update the current slider value (each time you drag the slider handle)
            slider3.oninput = function() {
                output3.innerHTML = this.value;
                update_error(this.value);
            }
        </script>
    </body>
</html>
